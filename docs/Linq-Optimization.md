# Linq Optimization

Linq optimization is one of the main reasons DistIL exists, ~~the other is gross underestimatation of how much time and effort it would take~~.

Currently, only simple _reduction_ (e.g. queries ending with ToArray(), Any(), and others) queries are transformed into imperative code.

The pass is defined in `LinqExpansion`, and contains most of the query identification logic. The actual code is generated by `QuerySynthesizer` and `QueryStage.Synth()`. 

The synthesizer does not actually inline lambdas (it just calls lambda's Invoke()). This step is left for another pass to deal with (InlineLambdas), in order to handle cases that will arrive with basic method inlining.

## Easy cases: reduction queries

```cs
//Original code:
int[] ArrayTransform(int[] arr) {
    return arr.Where(x => x > 0)
              .Select(x => x * 2)
              .ToArray();
}
//Roslyinified:
[CompilerGenerated]
class _PrivData {
    static _PrivData Instance = new();
    static Func<int, int> PredCache;
    static Func<int, bool> MapperCache;
    
    bool Pred(int x) => x > 0; 
    int Mapper(int x) => x * 2;
}
int[] ArrayTransform_Lowered(int[] arr) {
    // `field ??= value` gets lowered into `var tmp = field; if (tmp == null) { field = tmp = new Func(...); }`
    //It's fairly easy to recognize in the IR.
    var pred = _PrivData.PredCache ??= new Func<int, bool>(_PrivData.Instance, &_PrivData.Pred);
    var stage1 = Enumerable.Where(arr, pred);
    var mapper = _PrivData.MapperCache ??= new Func<int, bool>(_PrivData.Instance, &_PrivData.Mapper);
    var stage2 = Enumerable.Select(stage1, mapper);
    return stage2.ToArray();
}
//Expected _distillation_ (before lambda inlining)
int[] ArrayTransform_Distilled(int[] arr) {
    var pred = _PrivData.PredCache ??= new Func<int, bool>(_PrivData.Instance, &_PrivData.Pred);
    var mapper = _PrivData.MapperCache ??= new Func<int, bool>(_PrivData.Instance, &_PrivData.Mapper);

    var result = new int[arr.Length];
    int j = 0;
    for (int i = 0; i < arr.Length; i++) {
        int currItem = arr[i];
        if (pred.Invoke(currItem)) {
            result[j++] = mapper.Invoke(currItem);
        }
    }
    if (j != arr.Length) {
        var newResult = new int[j];
        Array.Copy(result, newResult, j);
        result = newResult;
    }
    return result;
}
```

## Complex cases: consumed queries

```cs
//Original code:
int PositiveSum(int[] arr) {
    int r = 0;
    foreach (int x in arr.Where(x => x > 0)) {
        r += x;
    }
    return r;
}
//Roslyinified:
int PositiveSum_Lowered(int[] arr) {
    int result = 0;
    IEnumerator<int> itr = Enumerable.Where(arr, <lambda magic shown previously>).GetEnumerator();
    try {
        while (itr.MoveNext()) {
            result += itr.Current;
        }
        return result;
    } finally {
        itr?.Dispose();
    }
}
//Distillation:
//  ???
```

It's not immediately clear how to go from _that_ to a simple for loop with an if inside, and to make things worse, we'd have to deal with exception handlers (which screws up SSA).

Altough a specialized transform could be more effective, general passes like method inlining, lambda inlining and SROA could give most of this optimization for free, so it may not be worth pursuing it too far. (We'd probably need to invest in other complicated passes to handle state machines and weird CFGs.)