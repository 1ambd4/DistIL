# DistIL
An experimental optimizer and IR for .NET CIL

# Feature status
- SSA-based Intermediate Representation
  - Type system powered by _System.Reflection.Metadata_*
  - Plain text and graphviz dumps
  - Parser for plain text dumps*
- Analyses:
  - Dominators
  - Natural Loops*
- Transforms:
  - Method Inlining*
  - Constant Folding and Peepholes
  - Local Value Numbering
  - Loop Invariant Code Motion*
  - Linq Expansion*
  - Local Delegate Devirtualization
  - Out of SSA translation based on _Boissinot et al._ methods

\* incomplete or unstable

Many CIL opcodes [are implemented](./src/DistIL/Frontend/BlockState.cs#L108) as well, in both frontend and backend. However, several other features are missing, incomplete, or poorly implemented (e.g. custom attributes, codegen for exception handlers, and pretty much all transforms).

# Overview and IR details
The IR is very similar to that of LLVM. Instructions are represented in _static single assignment_ form (meaning they output an immutable value that can be used by any other _dominated_ instruction, as opposed to being pushed into the evaluation stack as a temporary like in CIL). Data dependencies are direct references to `Value` objects (which may be other instructions), and def-use chains are implicitly managed. This allows for quick and easy pattern matching of expressions:

```cs
foreach (var inst in methodBody.Instructions()) {
  //`-x + y`  ->  `y - x`
  if (inst is BinaryInst { Op: BinaryOp.Add, Left: UnaryInst { Op: UnaryOp.Neg, Value: var x }, Right: var y }) {
    inst.ReplaceWith(new BinaryInst(BinaryOp.Sub, y, x), insertIfInst: true);
  }
}
```

## Modules and the Type System
Modules (assemblies) and all dependencies are fully loaded at once using _System.Reflection.Metadata_. This makes the code simpler by avoiding lazy properties and other issues caused by circular references, and eliminates the need of _TypeReference_ and similar placeholder entities (which can be annoying to deal with).

## Exceptions and Protected Regions
Exception control flow is implicit and not directly represented in the IR. This follows the CIL model, but hinders SSA when used in conjuction with handlers, because phi instructions can only merge values at block boundaries.

Protected regions are also represented as implicit sub-graphs of the main CFG. They start with a single entry block, containing one or more `GuardInst` instructions pointing to the entry block of the handler/filter regions (which are otherwise unreachable), and end with a single `LeaveInst` or `ContinueInst` (for filter/finally handlers) instruction.

## Code generation
Once phi instructions have been removed, CIL code is generated by simply visiting and emitting the appropriate opcodes for each IR instruction. To minimize the number of temporary variables and generate smaller code, some instructions are marked as _leafs_ and visited recursively. Leaf instructions only have a single use within the same block, and there are no interferences to any of its dependencies before the result is used.

Blocks of methods with exception handlers are ordered carefully in order to generate valid region ranges, which are linear in CIL. (The current implementation is actually not that careful and just uses a basic DFS.)

## IR dumps
The IR can be dumped into either plain text or graphviz forms. Plain text dumps can be parsed and rematerialized into IR, but they can be hard to read depending on the method complexity and branchiness. There are several ways to render graphviz dumps, one of them is using a [VSCode extension](https://marketplace.visualstudio.com/items?itemName=tintinweb.graphviz-interactive-preview).

### Showcase: Linq expansion
<table>
  <tr> <th>Original code</th> <th>Optimized CFG</th> </tr>
  <tr>
    <td>
      <pre lang="csharp">
static int[] Linq1(int[] arr) {
  return arr.Where(x => x > 0)
            .Select(x => x * 2)
            .ToArray();
}
      </pre>
    </td>
    <td>
      <img src="https://user-images.githubusercontent.com/87553666/194204401-a5662186-b83f-41cd-b5cd-70a8ade1e7b9.svg">
    </td>
  </tr>
</table>

That looks cool and all, but unlike most other most other compilers, the optimized result can be decompiled into high level code using a tool like ILSpy:

```cs
static int[] Linq1(int[] arr) {
  int num = arr.Length;
  int[] array = new int[num];
  int i = 0;
  int num2 = 0;
  for (; i < num; i++) {
    int num3 = arr[i];
    if (num3 > 0) {
      array[num2] = num3 * 2;
      num2++;
    }
  }
  if (num2 != num) {
    int[] array2 = new int[num2];
    Array.Copy(array, array2, num2);
    array = array2;
  }
  return array;
}
```
No variable names (yet!), but significantly more readable than an assembly-ish language.

### Showcase: Exception handlers
<table>
  <tr> <th>Original code</th> <th>Optimized CFG</th> </tr>
  <tr>
    <td>
      <pre lang="csharp">
static int Try2(string str) {
  int r = 0;
  try {
    r = str.Length > 0 ? int.Parse(str) : 0;
    r *= 5;
  } catch (FormatException ex) {
    Console.WriteLine(ex);
    r = -1;
  } finally {
    r += 30;
  }
  return r;
}
      </pre>
    </td>
    <td>
      <img src="https://user-images.githubusercontent.com/87553666/194204356-e058f90e-0c24-442f-94e8-5a6baae7ca8f.svg">
    </td>
  </tr>
</table>

This sample is not optimal in terms of the IR (there's a dead store and an empty block), but it shows how exception handlers are represented, and that variables used across protected regions are not _SSA-ified_ due to the issues mentioned earlier.

# Related projects
- https://github.com/jonathanvdc/Flame
- https://github.com/Washi1337/Echo
- https://github.com/edgardozoppi/analysis-net
